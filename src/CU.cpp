#include "CU.h"
#include <iostream>
#define deb(X) std::cout << #X << " = " << X << "; "

CU::CU()
{
    // ROM Programming
    std::vector<std::string> s(256,"0000000000000000000000000");

    // storing ROM data in strings for conversion from binary string to integer
    {
        //Sel ARPC DRM PCINC IRDR ARDR ACDR MDR DRAC INC DEC CLR PCDR ALU(4)  Next_state(8) // State         Name
        s[0 ] = "0100000000000000000000001";                                                // 00000000      fetch 1
        s[1 ] = "0011000000000000000000010";                                                // 00000001      fetch 2
        s[2 ] = "1000110000000000011111111";                                                // 00000010      fetch 3
        s[4 ] = "0010000000000000000000101";                                                // 00000100      load AC 1
        s[5 ] = "0000001000000000000000000";                                                // 00000101      load AC 2
        s[8 ] = "0000000010000000000001001";                                                // 00001000      Store AC 1
        s[9 ] = "0000000100000000000000000";                                                // 00001001      Store AC 2
        s[12] = "0010000000000000000001101";                                                // 00001100      ADD 1
        s[13] = "0000000000000000100000000";                                                // 00001101      ADD 2
        s[16] = "0010000000000000000010001";                                                // 00010000      SUB  1
        s[17] = "0000000000000001000000000";                                                // 00010001      SUB 2
        s[20] = "0010000000000000000010101";                                                // 00010100      AND 1
        s[21] = "0000000000000001100000000";                                                // 00010101      AND 2
        s[24] = "0010000000000000000011001";                                                // 00011000      OR 1
        s[25] = "0000000000000011000000000";                                                // 00011001      OR 2
        s[28] = "0010000000000000000011101";                                                // 00011100      XOR 1
        s[29] = "0000000000000010000000000";                                                // 00011101      XOR 2
        s[32] = "0000000000001000000000000";                                                // 00100000      JMPC 1
        s[36] = "0000000000001000000000000";                                                // 00100100      JNC 1
        s[40] = "0000000000001000000000000";                                                // 00101000      JMP 1
        s[44] = "0000000000001000000000000";                                                // 00101100      JMPZ 1
        s[48] = "0000000000001000000000000";                                                // 00110000      JNZ 1
        s[52] = "0000000001000000000000000";                                                // 00110100      INC
        s[56] = "0000000000100000000000000";                                                // 00111000      DEC
        s[60] = "0000000000000010100000000";                                                // 00111100      NOT
        s[64] = "0000000000010000000000000";                                                // 01000000      CLR
        s[68] = "0000000000000100000000000";                                                // 01000100      SHL
        s[72] = "0000000000000011100000000";                                                // 01001000      SHR
        s[76] = "0000000000000101000000000";                                                // 01001100      CIL
        s[80] = "0000000000000100100000000";                                                // 01010000      CIR
        s[84] = "0000000000000110000000000";                                                // 01010100      ASL
        s[88] = "0000000000000101100000000";                                                // 01011000      ASR
        s[92] = "0000000000000000001011100";                                                // 01011100      HLT

        s[132] = "0010000000000000010000101";                                               // 10000100 	ILOAD AC 1
        s[133] = "0000010000000000010000110";                                               // 10000101 	ILOAD AC 2
        s[134] = "0010000000000000010000111";                                               // 10000110 	ILOAD AC 3
        s[135] = "0000001000000000000000000";                                               // 10000111 	ILOAD AC 4
        s[136] = "0010000000000000010001001";                                               // 10001000 	ISTORE AC 1
        s[137] = "0000010000000000010001010";                                               // 10001001 	ISTORE AC 2
        s[138] = "0000000010000000010001011";                                               // 10001010 	ISTORE AC 3
        s[139] = "0000000100000000000000000";                                               // 10001011 	ISTORE AC 4
        s[140] = "0010000000000000010001101";                                               // 10001100 	IADD 1
        s[141] = "0000010000000000010001110";                                               // 10001101 	IADD 2
        s[142] = "0010000000000000010001111";                                               // 10001110 	IADD 3
        s[143] = "0000000000000000100000000";                                               // 10001111 	IADD 4
        s[144] = "0010000000000000010010001";                                               // 10010000 	ISUB 1
        s[145] = "0000010000000000010010010";                                               // 10010001     ISUB 2
        s[146] = "0010000000000000010010011";                                               // 10010010     ISUB 3
        s[147] = "0000000000000001000000000";                                               // 10010011 	ISUB 4
        s[148] = "0010000000000000010010101";                                               // 10010100 	IAND 1
        s[149] = "0000010000000000010010110";                                               // 10010101 	IAND 2
        s[150] = "0010000000000000010010111";                                               // 10010110 	IAND 3
        s[151] = "0000000000000001100000000";                                               // 10010111 	IAND 4
        s[152] = "0010000000000000010011001";                                               // 10011000 	IOR 1
        s[153] = "0000010000000000010011010";                                               // 10011001 	IOR 2
        s[154] = "0010000000000000010011011";                                               // 10011010 	IOR 3
        s[155] = "0000000000000011000000000";                                               // 10011011 	IOR 4
        s[156] = "0010000000000000010011101";                                               // 10011100 	IXOR 1
        s[157] = "0000010000000000010011110";                                               // 10011101 	IXOR 2
        s[158] = "0010000000000000010011111";                                               // 10011110 	IXOR 3
//        s[159] = "0000000000000010000000000";                                               // 10011111 	IXOR 4
//        s[160] = "0010000000000000010100001";                                               // 10100000 	IJMPC 1
//        s[161] = "0000010000000000010100010";                                               // 10100001 	IJMPC 2
//        s[162] = "0010000000000000010100011";                                               // 10100010 	IJMPC 3
//        s[163] = "0000000000001000000000000";                                               // 10100011 	IJMPC 4
//        s[164] = "0010000000000000010100101";                                               // 10100100 	IJNC 1
//        s[165] = "0000010000000000010100110";                                               // 10100101 	IJNC 2
//        s[166] = "0010000000000000010100111";                                               // 10100110 	IJNC 3
//        s[167] = "0000000000001000000000000";                                               // 10100111 	IJNC 4
//        s[168] = "0010000000000000010101001";                                               // 10101000 	IJMP 1
//        s[169] = "0000010000000000010101010";                                               // 10101001 	IJMP 2
//        s[170] = "0010000000000000010101011";                                               // 10101010 	IJMP 3
//        s[171] = "0000000000001000000000000";                                               // 10101011 	IJMP 4
//        s[172] = "0010000000000000010101101";                                               // 10101100 	IJMPZ 1
//        s[173] = "0000010000000000010101110";                                               // 10101101 	IJMPZ 2
//        s[174] = "0010000000000000010101111";                                               // 10101110 	IJMPZ 3
//        s[175] = "0000000000001000000000000";                                               // 10101111 	IJMPZ 4
//        s[176] = "0010000000000000010110001";                                               // 10110000 	IJNZ 1
//        s[177] = "0000010000000000010110010";                                               // 10110001 	IJNZ 2
//        s[178] = "0010000000000000010110011";                                               // 10110010 	IJNZ 3
//        s[179] = "0000000000001000000000000";                                               // 10110011 	IJNZ 4
    }

    // assigning data to ROM
    int n = 256;
    ROM.resize(n);
    for(int i = 0; i < n; i++){
        std::bitset<30> word(s[i]);
        ROM[i] = word.to_ullong();
    }

    // resetting signals
    PRINT = READ = WRITE = ARPC = DRM = PCINC = IRDR = ARDR = ACDR = MDR = DRAC = INC = DEC = CLR = PCDR = 0;
    ALU = 0;
    implicit_address = 0;
    select_mapped_address = 0;
}

CU::~CU(){}

void CU::next_state(Register& reg, bool CF, bool ZF, bool MF) // reg is IR
{
    int micro_code;

    if(select_mapped_address == 1){
        int mapped_state = instruction_map(reg, CF, ZF, MF);
        micro_code = ROM[mapped_state];
    }
    else{
        micro_code = ROM[implicit_address];
    }

    // assign all control signals next_address and select signal
    std::bitset<30> code(micro_code);

    select_mapped_address = code[24];
    ARPC  = code[23];
    READ = code[22];
    PCINC = code[21];
    IRDR = code[20];
    ARDR = code[19];
    ACDR = code[18];
    WRITE = code[17];
    DRAC = code[16];
    INC = code[15];
    DEC = code[14];
    CLR = code[13];
    PCDR = code[12];
    ALU = (3840 & micro_code) >> 8; // to get only 8-12th bits
    implicit_address = 255 & micro_code; // to get only 8 bits
}

int CU::instruction_map(Register& reg, bool CF, bool ZF, bool MF)
{
    // if this instruction is conditional and condition is failed then we must ignore this instruction
    if(reg.getData() == 8 && CF == 0)return 0;
    if(reg.getData() == 9 && CF == 1)return 0;
    if(reg.getData() == 11 && ZF == 0)return 0;
    if(reg.getData() == 12 && ZF == 1)return 0;
    if(reg.getData() == 23) PRINT = 1;     // for Printing result after halt instruction


    // mapping instruction to corresponding starting address of state
    int mapping = int(MF) << 7; // assigning mode(direct/indirect) bit
    mapping += reg.getData() << 2; // assigning bits after 2nd bit

    return mapping;
}
